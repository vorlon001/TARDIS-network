Повторное использование Допустимые артефакты
============================================

Вы можете написать простую плейбук в одном очень большом файле,и большинство пользователей сначала изучат однофайловый подход.Однако разбиение заданий на разные файлы-отличный способ организовать сложные наборы заданий и использовать их повторно.Более мелкие,более распределенные артефакты позволяют повторно использовать одни и те же переменные,задачи и игры в нескольких плейбуках для различных случаев использования.Вы можете использовать распределенные артефакты по нескольким родительским книгам воспроизведения или даже несколько раз в одной книге воспроизведения.Например,вы можете обновить свою клиентскую базу данных как часть нескольких различных плейбуков.Если вы поместите все задачи,связанные с обновлением базы данных,в файл задач,вы можете повторно использовать их во многих плейбоках,сохраняя их только в одном месте.

*   [Создание многократно используемых файлов и ролей](#creating-re-usable-files-and-roles)
*   [Re-using playbooks](#re-using-playbooks)
*   [Повторное использование файлов и ролей](#re-using-files-and-roles)
    
    *   [Включает:динамическое повторное использование](#includes-dynamic-re-use)
    *   [Импорт:статическое повторное использование](#imports-static-re-use)
    *   [Сравнение включает в себя и импортирует:динамическое и статическое повторное использование](#comparing-includes-and-imports-dynamic-and-static-re-use)
*   [Повторное использование задач в качестве обработчиков](#re-using-tasks-as-handlers)
    
    *   [Включенные (динамические)обработчики триггеров](#triggering-included-dynamic-handlers)
    *   [Импортируемые (статические)обработчики триггеров](#triggering-imported-static-handlers)

Создание многократно используемых файлов и ролей
------------------------------------------------

Ansible предлагает четыре распределенных,повторно используемых артефакта:файлы переменных,файлы задач,плейбуки и роли.

*   Файл с переменными содержит только переменные.
*   Файл задачи содержит только задачи.
*   Пьеса содержит,по крайней мере,одну пьесу и может содержать переменные,задания и другое содержимое.Вы можете повторно использовать плотно сфокусированные плейбуки,но вы можете использовать их только статически,а не динамически.
*   Роль содержит набор связанных задач, переменных, значений по умолчанию, обработчиков и даже модулей или других подключаемых модулей в определенном дереве файлов. В отличие от файлов переменных, файлов задач или сценариев, роли можно легко загружать и совместно использовать через Ansible Galaxy. См. [Роли](playbooks_reuse_roles#playbooks-reuse-roles) для получения подробной информации о создании и использовании ролей.

Новинка в версии 2.4.

Re-using playbooks
------------------

Вы можете включить несколько игровых книг в основную игровую книгу.Однако импорт можно использовать только для повторного использования плейбуков.Например:

- import_playbook: webservers.yml
- import_playbook: databases.yml

Импорт включает плейбуки в другие плейбуки статически.Ansible запускает пьесы и задачи в каждом импортированном плейбуке в порядке их перечисления,как если бы они были определены непосредственно в главном плейбуке.

Повторное использование файлов и ролей
--------------------------------------

Возможны два способа повторного использования файлов и ролей в плейбуке:динамический и статический.

*   For dynamic re-use, add an `include_*` task in the tasks section of a play:
    
    *   [include_role](../collections/ansible/builtin/include_role_module#include-role-module)
    *   [include_tasks](../collections/ansible/builtin/include_tasks_module#include-tasks-module)
    *   [include_vars](../collections/ansible/builtin/include_vars_module#include-vars-module)
*   Для статического повторного использования добавьте задачу `import_*` в раздел задач игры:
    
    *   [import_role](../collections/ansible/builtin/import_role_module#import-role-module)
    *   [import_tasks](../collections/ansible/builtin/import_tasks_module#import-tasks-module)

Операции включения и импорта могут быть использованы на произвольной глубине.

Вы по-прежнему можете использовать ключевое слово bare [roles](playbooks_reuse_roles#roles-keyword) на уровне игры, чтобы статически включить роль в playbook. Однако ключевое слово bare [include](../collections/ansible/builtin/include_module#include-module) , которое когда-то использовалось как для файлов задач, так и для включений на уровне playbook, теперь устарело.

### Включает:динамическое повторное использование

Включая роли,задачи или переменные,динамически добавляет их в плейбук.Включаемые процессы включают файлы и роли по мере их появления в книге воспроизведения,поэтому включенные задачи могут быть подвержены влиянию результатов более ранних задач в книге воспроизведения верхнего уровня.Включенные роли и задачи похожи на обработчики-они могут выполняться или не выполняться,в зависимости от результатов выполнения других задач в учебнике воспроизведения верхнего уровня.

Основное преимущество использования операторов `include_*` - это зацикливание. Когда цикл используется с включением, включенные задачи или роль будут выполняться один раз для каждого элемента в цикле.

Вы можете передавать переменные в include. См. [раздел Приоритет переменных: куда поместить переменную?](playbooks_variables?page=2#ansible-variable-precedence) для получения более подробной информации о наследовании и приоритете переменных.

### Импорт:статическое повторное использование

Импорт ролей,задач или плейбуков статически добавляет их в плейбук.Возможна предварительная обработка импортируемых файлов и ролей перед выполнением каких-либо задач в книге воспроизведения,поэтому импортированный контент никогда не будет затронут другими задачами в книге воспроизведения верхнего уровня.

Вы можете передавать переменные на импорт.Вы должны передавать переменные,если хотите запустить импортированный файл более одного раза в книге воспроизведения.Например:
```
tasks:
- import_tasks: wordpress.yml
  vars:
    wp_user: timmy

- import_tasks: wordpress.yml
  vars:
    wp_user: alice

- import_tasks: wordpress.yml
  vars:
    wp_user: bob
```
См. [раздел Приоритет переменных: куда поместить переменную?](playbooks_variables?page=2#ansible-variable-precedence) для получения более подробной информации о наследовании и приоритете переменных.

### Сравнение включает в себя и импортирует:динамическое и статическое повторное использование

Каждый подход к повторному использованию распределенных Артефактов имеет свои преимущества и ограничения.Вы можете выбрать динамическое повторное использование для одних плейбуков и статическое повторное использование для других.Хотя вы можете использовать как динамическое,так и статическое повторное использование в одной книге воспроизведения,лучше всего выбрать один подход для каждой книги воспроизведения.Смешивание статического и динамического повторного использования может ввести трудно-диагностировать ошибок в ваших пьесах.В этой таблице приведены основные различия,чтобы вы могли выбрать наилучший подход для каждого создаваемого вами плейбога.
```
Include_*

Import_*
```
Тип повторного использования
```
Dynamic

Static

When processed
```
Во время работы,при встрече

Предварительно обработанный во время разбора плейбука

Задача или игра

Все включает в себя задачи

`import_playbook` не может быть задачей

Task options

Применяется только для включения самой задачи

Применяется ко всем дочерним задачам в импорте

Вызов из петель

Выполняется один раз для каждого элемента петли

Не может быть использован в петле

Using `--list-tags`

Теги внутри включают в себя не перечисленные

Все теги отображаются с `--list-tags`

Using `--list-tasks`

Задачи,включенные в список,не указаны

Все задачи отображаются с `--list-tasks`

Notifying handlers

Невозможно спусковые крючки в комплекте включает в себя

Может инициировать индивидуальные импортные обработчики

Using `--start-at-task`

Не могу начать с задач в рамках включает в себя

Может начать с импортированных задач

Использование инвентаризационных переменных

Can `include_*: {{ inventory_var }}`

Cannot `import_*: {{ inventory_var }}`

With playbooks

No `include_playbook`

Может импортировать полные плейбуки

С файлами переменных

Может включать переменные файлы

Use `vars_files:` to import variables

Note

*   Также существуют большие различия в потреблении ресурсов и производительности,импортные компании достаточно бережливы и быстры,в то время как импортные требуют много управления и учета.

Повторное использование задач в качестве обработчиков
-----------------------------------------------------

Вы также можете использовать include и import в разделе [Handlers: running operations on change](playbooks_handlers#handlers) в playbook. Например, если вы хотите определить, как перезапустить Apache, вам нужно сделать это только один раз для всех ваших playbook. Вы можете создать файл `restarts.yml` , который выглядит так:
```
# restarts.yml
- name: Restart apache
  ansible.builtin.service:
    name: apache
    state: restarted

- name: Restart mysql
  ansible.builtin.service:
    name: mysql
    state: restarted
```
Вы можете запускать обработчики либо из импорта, либо из включения, но процедура отличается для каждого метода повторного использования. Если вы включаете файл, вы должны уведомить само включение, которое запускает все задачи в `restarts.yml` . Если вы импортируете файл, вы должны уведомить об отдельных задачах в файле `restarts.yml` . Вы можете смешивать прямые задачи и обработчики с включенными или импортированными задачами и обработчиками.

### Включенные (динамические)обработчики триггеров

Включения выполняются во время выполнения, поэтому имя включения существует во время выполнения воспроизведения, но включенные задачи не существуют до тех пор, пока не будет запущено само включение. Чтобы использовать задачу `Restart apache` с динамическим повторным использованием, обратитесь к имени самого включения. Этот подход запускает все задачи во включенном файле в качестве обработчиков. Например, с файлом задачи, показанным выше:
```
- name: Trigger an included (dynamic) handler
  hosts: localhost
  handlers:
    - name: Restart services
      include_tasks: restarts.yml
  tasks:
    - command: "true"
      notify: Restart services
```
### Импортируемые (статические)обработчики триггеров

Импорты обрабатываются до начала воспроизведения, поэтому имя импорта больше не существует во время выполнения воспроизведения, но имена отдельных импортированных задач существуют. Чтобы использовать задачу `Restart apache` со статическим повторным использованием, обратитесь к имени каждой задачи или задач в импортированном файле. Например, с файлом задачи, показанным выше:
```
- name: Trigger an imported (static) handler
  hosts: localhost
  handlers:
    - name: Restart services
      import_tasks: restarts.yml
  tasks:
    - command: "true"
      notify: Restart apache
    - command: "true"
      notify: Restart mysql
```
